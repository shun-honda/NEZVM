import sys
import re

argvs = sys.argv
argc = len(argvs)

if argc < 2:
	print 'Error: Not enough arguments'
	quit()

f = open(argvs[1], 'r')
if f==None:
	print 'Error: File not found'
	quit()

class Expr:
	"""docstring for Expr"""
	def __init__(self, name, num):
		self.name = name
		self.num = num
		self.type = None
		self.code = None
	def append(self, line):
		self.code += line

i = 0
exprs = []
p = re.compile('#([^:]*):(?:(list)|(unary)|(term)|(nonterm)|(tag)|(val)|(func))|(^{)|(^})')
while True:
	line = f.readline()
	m = p.match(line)
	if line != '':
		if m:
			if m.group(1):
				cur = Expr(m.group(1), i)
				i += 1
				if m.group(2):
					cur.type = 0
				elif m.group(3):
					cur.type = 1
				elif m.group(4):
					cur.type = 2
				elif m.group(5):
					cur.type = 3
				elif m.group(6):
					cur.type = 4
				elif m.group(7):
					cur.type = 5
				elif m.group(8):
					cur.type = 6
			elif m.group(9):
					cur.code = ""
			else:
				exprs.append(cur)
				cur = None
		else:
			cur.append(line)
	else:
		break;

print "// This file is auto generated by gen/gen_parser_combinator.py\n"

print "#define NEZ_MAX_EXPR " + str(i-1)

print "#define NEZ_EXPR_EACH(EXPR)\\"
for expr in exprs:
	print "\tEXPR(" + expr.name + ")\\"

print

for expr in exprs:
	print "#define NEZ_" + expr.name.upper() + " " + str(expr.num)
	print "struct nez_" + expr.name + "{"
	print "\tnez_expr_base base;"
	print expr.code + "};"
	print "typedef struct nez_" + expr.name + " nez_" + expr.name + ";\n"

for expr in exprs:
	if expr.type == 0:
		print "#define nez_new_" + expr.name + "(...)\\"
		print "\t(nez_expression[][]){ __VA_ARGS__ },\\"
		print "\tsizeof((nez_expression[][]){ __VA_ARGS__ }) / sizeof(nez_expression)\\"
		print "\t)"
		print "nez_expression* _nez_new_" + expr.name + "(nez_expression **expr, size_t size);"
	elif expr.type == 2:
		print "nez_expression* nez_new_" + expr.name + "(char* byteChar);"
	else:
		print "nez_expression* nez_new_" + expr.name + "(nez_expression *expr);"
	print "void nez_dispose_" + expr.name + "(nez_expression *expr);"
print "\n"

for expr in exprs:
	if expr.type == 0:
		print "nez_expression* _nez_new_" + expr.name + "(nez_expression **expr, size_t size) {"
	elif expr.type == 2:
		print "nez_expression* nez_new_" + expr.name + "(char* byteChar) {"
	else:
		print "nez_expression* nez_new_" + expr.name + "(nez_expression *expr) {"
	print "\tnez_" + expr.name + " *e = (nez_"+ expr.name +"*)malloc(sizeof(nez_"+ expr.name +"));"
	print "\te->base.expr = NEZ_" + expr.name.upper() + ";"
	if expr.type == 0:
		print "\te->base.size = size;"
		print "\te->list = (nez_expression**) malloc(sizeof(nez_expression*)*size);"
		print "\tfor(size_t i = 0; i < size; i++) {"
		print "\t\te->list[i] = expr[i];"
		print "\t}"
	elif expr.type == 1:
		print "\te->base.size = 1;"
		print "\te->inner = expr;"
	else:
		print "\te->base.size = 0;"
	print "\treturn (nez_expression *)e;"
	print "}\n"
	print "void nez_dispose_" + expr.name + "(nez_expression *expr) {"
	if expr.type == 0:
		print "\tnez_"+ expr.name +"* e = (nez_"+ expr.name +"*)expr;"
		print "\tfor(size_t i = 0; i < e->base.size; i++) {"
		print "\t\tf_dispose_expr[e->list[i]->base.expr](e->list[i]);"
		print "\t}"
		print "\tfree(e->list);"
	elif expr.type == 1:
		print "\tnez_"+ expr.name +"* e = (nez_"+ expr.name +"*)expr;"
		print "\tf_dispose_expr[e->inner->base.expr](e->inner);"
		print "\tfree(e->inner);"
	print "\tfree(e);"
	print "}\n"

for expr in exprs:
	print "#define " + expr.name.upper() + " nez_new_" + expr.name
print "\n"